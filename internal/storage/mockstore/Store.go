// Code generated by mockery v0.0.0-dev. DO NOT EDIT.

// Regenerate using `make store_mocks`

package mocks

import (
	storage "everyflavor/internal/storage"

	mock "github.com/stretchr/testify/mock"
)

// Store is an autogenerated mock type for the Store type
type Store struct {
	mock.Mock
}

// Auth provides a mock function with given fields:
func (_m *Store) Auth() storage.AuthStore {
	ret := _m.Called()

	var r0 storage.AuthStore
	if rf, ok := ret.Get(0).(func() storage.AuthStore); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(storage.AuthStore)
		}
	}

	return r0
}

// Batch provides a mock function with given fields:
func (_m *Store) Batch() storage.BatchStore {
	ret := _m.Called()

	var r0 storage.BatchStore
	if rf, ok := ret.Get(0).(func() storage.BatchStore); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(storage.BatchStore)
		}
	}

	return r0
}

// Connection provides a mock function with given fields:
func (_m *Store) Connection() storage.DB {
	ret := _m.Called()

	var r0 storage.DB
	if rf, ok := ret.Get(0).(func() storage.DB); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(storage.DB)
		}
	}

	return r0
}

// DB provides a mock function with given fields:
func (_m *Store) DB() storage.DBQueryExecer {
	ret := _m.Called()

	var r0 storage.DBQueryExecer
	if rf, ok := ret.Get(0).(func() storage.DBQueryExecer); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(storage.DBQueryExecer)
		}
	}

	return r0
}

// Flavor provides a mock function with given fields:
func (_m *Store) Flavor() storage.FlavorStore {
	ret := _m.Called()

	var r0 storage.FlavorStore
	if rf, ok := ret.Get(0).(func() storage.FlavorStore); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(storage.FlavorStore)
		}
	}

	return r0
}

// Recipe provides a mock function with given fields:
func (_m *Store) Recipe() storage.RecipeStore {
	ret := _m.Called()

	var r0 storage.RecipeStore
	if rf, ok := ret.Get(0).(func() storage.RecipeStore); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(storage.RecipeStore)
		}
	}

	return r0
}

// Stash provides a mock function with given fields:
func (_m *Store) Stash() storage.FlavorStashStore {
	ret := _m.Called()

	var r0 storage.FlavorStashStore
	if rf, ok := ret.Get(0).(func() storage.FlavorStashStore); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(storage.FlavorStashStore)
		}
	}

	return r0
}

// Tag provides a mock function with given fields:
func (_m *Store) Tag() storage.TagStore {
	ret := _m.Called()

	var r0 storage.TagStore
	if rf, ok := ret.Get(0).(func() storage.TagStore); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(storage.TagStore)
		}
	}

	return r0
}

// User provides a mock function with given fields:
func (_m *Store) User() storage.UserStore {
	ret := _m.Called()

	var r0 storage.UserStore
	if rf, ok := ret.Get(0).(func() storage.UserStore); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(storage.UserStore)
		}
	}

	return r0
}

// Vendor provides a mock function with given fields:
func (_m *Store) Vendor() storage.VendorStore {
	ret := _m.Called()

	var r0 storage.VendorStore
	if rf, ok := ret.Get(0).(func() storage.VendorStore); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(storage.VendorStore)
		}
	}

	return r0
}
